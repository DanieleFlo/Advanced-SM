---
title: "Analisi_finale"
output:
  pdf_document: default
  html_document: default
---

# Introduzione


Di seguito riportiamo la lista delle librerie utilizzate nell'elaborazione del dataset.
```{r echo=TRUE, warning=FALSE, message=FALSE}
library(lme4)
library(tidyverse)
library(RColorBrewer)
library(lmerTest)
library(gamlss)
library(ggcorrplot)
library(fitdistrplus)
```


# Descrizione e caricamento del dataset

Il dataset RiceFarms è stato iportato attaverso il seguente codice e inoltre vengono presentate le prime 5 righe del dataset:
```{r, warning=FALSE}
load("DataRegression2025_unical.RData")
data=data.frame(RiceFarms)
# Trasformiao la varaiblie in fattore in modo da avere una rappresentazione
# corretta del dataset
data$id = as.factor(data$id) 
attach(data)
head(data)
```

Prima dell'analisi è stata utilizzata la funzione $which(is.na(data))$ per vedere se ci fossero eventuali valori mancanti. Il dataset non presenta valori mancanti. Di seguito possiamo ossere il tipo di variabili prensti nel dataset:

```{r}
str(data)
```

### Descrizioni variabili

Vediamo una breve descrizione delle variabili presenti nel dataset:
- id: identificativo univoco dell'azienda agricola.

- CARATTERISTICHE DEL TERRENO: SUDDIVISE IN ETTARI COLTIVATI E PROPRIETA' DEL TERRENO
  - size: area totale coltivata a riso (in ettari).
  - status: stato della terra coltivata, che può essere:
    - owner: agricoltori proprietari o affittuari (non mezzadri).
    - share: mezzadri.
    - mixed: combinazione delle due categorie precedenti.

  - varieties: tipo di varietà di riso coltivate:
    - trad: varietà tradizionali.
    - high: varietà ad alta resa.
    - mixed: combinazione delle due varietà.
  - bimas: partecipazione al programma di intensificazione BIMAS:
    - no: non partecipante.
    - yes: partecipante.
    - mixed: solo una parte del terreno è registrata nel programma.

- FATTORI DI INPUT PRODUTTIVI: COSTO DELLE MATERIE PRIME E TIPOLOGIA
  - seed: quantità di semi utilizzati (kg).
  - urea: quantità di urea utilizzata (kg).
  - phosphate: quantità di fosfato utilizzata (kg).
  - pesticide: costo dei pesticidi (in Rupiah).
  - pseed: prezzo del seme (in Rupiah per kg).
  - purea: prezzo dell'urea (in Rupiah per kg).
  - pphosph: prezzo del fosfato (in Rupiah per kg).

- INPUT: COSTI DEL PERSONALE E ORE DI LAVORO
  - hiredlabor: ore di lavoro salariato.
  - famlabor: ore di lavoro familiare.
  - totlabor: totale ore di lavoro (escludendo il raccolto).
  - wage: salario della manodopera (in Rupiah per ora).

- PRODUZIONE LORDA E NETTA 
  - goutput: produzione lorda di riso (kg).
  - noutput: produzione netta di riso, calcolata sottraendo il costo del raccolto dalla produzione lorda.
  - price: prezzo del riso grezzo (in Rupiah per kg).

- AREE GEOGRAFICHE IN CUI OPERANO LE AZIENDE:
  - region: area geografica di appartenenza dell’azienda agricola, tra:
    - wargabinangun
    - langan
    - gunungwangi
    - malausma
    - sukaambit
    - ciwangi



# Analisi preliminare

In questo paragrafo analizziamo le variabili presenti nel dataset. Questa analisi ci permette di comprendere meglio la distribuzione dei dati e di valutare il loro andamento rispetto alla variabile target (price), ovvero il prezzo, fondamentale per la costruzione del nostro modello.

Attraverso la funzione summary possiamo osservare che il dataset è di tipo multilivello. In quanto, i dati relativi a ciascuna azienda sono stati osservati su diversi cicli di produzione. Dalla variabile price possiamo osservare come questi presentino un'asimmetria positiva con una coda molto lunga, lasciando intendere una forte variabilità della distribuzione.
```{r}
summary(data)
print(paste('Deviazione standard di price:', sd(price)))
```


Nel seguente grafico è riporto l'instogramma della variabile price. Questo ci suggerisce il tipo distribuzione che potrebbe assumere la variabile prezzo. Tuttavia, questa non sembra ben definita dato che i valori sembrano concentrarsi intorno a due valori distinti di prezzo.
```{r}
ggplot(data, aes(x = price)) +
  geom_histogram(binwidth = 10, fill = "lightblue", color = "black") +
  theme_minimal() +
  labs(title = "Distribuzione dei prezzi")
```

```{r}
# Fitting diretto alla lognormale
fit <- fitdist(price, "lnorm")
#fit <- fitdist(price*goutput, "gamma")
 
# Mostra i parametri
summary(fit)
plot(fit)
```

Riportiamo di seguito la matrice di correlazione fra le variabili contenute nel dataset. Essendo presenti numerose colonne, questa matrice offre una visione chiara delle potenziali relazioni esistenti tra di esse. Si può notare come molte variabili siano fortemente correlate tra loro, e non solo con la variabile price. Gran parte di queste correlazioni risultano di facile interpretazione, come nel caso delle variabili goutput e noutput, che indicano rispettivamente la produzione lorda di riso in kg e la produzione netta, calcolata sottraendo il costo del raccolto dalla produzione lorda.
```{r}
matrix_corrplot = round(cor(select_if(data, is.numeric), method="pearson"),4)
ggcorrplot(matrix_corrplot, hc.order=T, type="lower", lab=T, lab_size = 2.7)
```

Nel grafico riportiamo il valore della variabile price (sull'asse delle ordinate) in funzione del salario orario della manodopera (sull'asse delle ascisse), colorando i punti in base alla regione di appartenenza. L'obiettivo era indagare se esistesse una correlazione tra il prezzo e il salario dei lavoratori, variabile al variare delle regioni. Dal grafico emerge la presenza di due gruppi distinti: in uno sembrano concentrarsi salari e prezzi elevati, mentre nell'altro salari e prezzi risultano nettamente inferiori. È importante precisare che, dal dataset non si riesce a motivare la presenza di questi due gruppi così distinti.

```{r}
ggplot(data, aes(x = wage, y = price, color = region)) +
  geom_point() +
  labs(
    x = "Wage",
    y = "Price",
    title = "Scatter Plot: Wage vs Price"
  ) +
  theme_minimal()
```

Nel grafico osserviamo la relazione tra il prezzo del riso (asse delle ordinate) e il prezzo dei semi (asse delle ascisse). I dati sono stati raggruppati per id e suddivisi per regione, evidenziati da colori differenti in base alla regione, e per ciascun gruppo è stata tracciata una retta di regressione lineare. Da tale analisi emerge che, per ogni variazione unitaria del prezzo dei semi, il corrispondente cambiamento nel prezzo del riso varia a seconda della regione di appartenenza.
```{r}
ggplot(data, aes(x = pseed, y = price, group = id, color = region)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE) +
  labs(
    x = "pseed",
    y = "Price",
    title = "Scatter Plot: pseed vs Price con fit lineare per ogni Region"
  ) +
  theme_minimal()
```

Nei grafici seguenti analizziamo se, nelle diverse regioni, vengano coltivate le stesse varietà di riso e in quale misura. Questa analisi risulta particolarmente interessante poiché varietà differenti di riso sono associate a prezzi diversi. Dal grafico si evince che vi sia molta differenza fra le regioni in termini di varietà di riso coltivate e di prezzo a cui queste vengono vendute. 
```{r}
ggplot(data, aes(x = varieties, y = price, fill = varieties)) +
  geom_boxplot() +
  # Facet per regione, scales="free" permette ad ogni grafico 
  # di avere le proprie scale
  facet_wrap(~ region, scales = "free") +  
  labs(title = "Boxplot dei Prezzi per Varietà per Regione",
       x = "Varietà", y = "Prezzo") +
  theme_minimal() +
  theme(legend.position = "none")

# Ripristino il layout di default
par(mfrow = c(1, 1))
```

In questi due grafici si evince l'assenza di una correlazione sia tra la quantità di semi utilizzata e il prezzo del riso, sia tra la dimensione del campo di coltivazione e il prezzo del riso.
```{r}
ggplot(data, aes(x = size, y = price, color = region)) +
  geom_point() +
  labs(
    x = "size",
    y = "Price",
    title = "Scatter Plot: size vs Price con fit lineare per ogni Region"
  ) +
  theme_minimal()

ggplot(data, aes(x = seed, y = price, color = varieties)) +
  geom_point() +
  labs(
    x = "seed",
    y = "Price",
    title = "Scatter Plot: seed vs Price con fit lineare per ogni Region"
  ) +
  theme_minimal()
```

# Analisi

## Effetti casuali sulla variabile ID

Terminata l'esplorazione del dataset, ci siamo concentrati sul capire quali fossero i fattori più significativi nella determinazione del prezzo del riso per le diverse aziende. In particolare si è utilizzato un modello di regressione lineare a effetti casuali. In questo modello l'attribuzione degli effetti casuali è stata legata alle diverse aziende distinte per ID. Inoltre, per semplicità inizialmente si sono utilizzate solo alcune variabili quali: pseed, purea e wage.

```{r}
model.1<-lmer(price~1 + pseed + purea + wage + (1|id), data=data)
summary(model.1)
```
Si può notare che nel primo modello le variabili inserite risultino significative tranne per l'intercetta. In quanto sia un prezzo negativo non risulta ragionevole, sia il suo valore di p-value risulta troppo elevato.

Nel blocco di codice seguente sono stati implementati due modelli, entrambi senza intercetta, in linea con le considerazioni precedenti. In particolare, sono state aggiunte ulteriori variabili, tra cui la varieties. Poiché quest'ultima è di tipo categorico, è stato eseguito un test AIC per valutare se la sua inclusione migliorasse il modello o meno. Il test ha evidenziato un miglioramento con la presenza della variabile. Tuttavia, nel summary si osserva che il p-value associato agli effetti casuali è molto elevato, indicando che tali effetti non sono statisticamente significativi e dunque da escludere.

```{r}
print("-----Model 2-----")
model.2<-lmer(price~0 + pseed + purea + wage +varieties + bimas + (1|id), data=data)
model.2B<-lmer(price~0 + pseed + purea + wage + bimas + (1|id), data=data)
AIC(model.2, model.2B)
summary(model.2)
ranova(model.2)
```

## Effetti casuali sulla variabile region
```{r}
regioni_id <- unique(data$region)
regione_mappa <- setNames(seq_along(regioni_id), regioni_id)

data_2 <- data %>%
  mutate(Regione_id = recode(region, !!!regione_mappa))
#data_2$Regione_id = as.factor(data_2$Regione_id)
attach(data_2)
head(data_2)
```

```{r}
print("-----Model 2 BIS-----")
model.2B<-lmer(price~0 + pseed + purea + wage + varieties + bimas + pesticide + urea + phosphate  + (1|Regione_id), data=data_2)
model.2B_2<-lmer(price~0 + pseed + purea + wage +bimas+ pesticide + urea + phosphate + (1|Regione_id), data=data_2)
AIC(model.2B, model.2B_2) # Il modello con la variabile varieties ha un AIC migliore
summary(model.2B)
ranova(model.2B)
```

# GAMLSS

```{r}
mod_ga<- gamlss(price~ 1+ pseed + purea + wage + varieties + bimas + pesticide + goutput + noutput + (1|Regione_id), family = GA, data =data_2)
summary(mod_ga)
res=residuals(mod_ga)
```

```{r}
res=residuals(mod_ga)
ggplot(data.frame(res), aes(x = res)) +
  geom_histogram(binwidth = 0.1, fill = "blue", color = "black", alpha = 0.7) +
  labs(title = "Istogramma dei residui", x = "Residui", y = "Frequenza")
```



```{r}
par(mfrow=c(1,2))

qqnorm(res)
qqline(res, col = "red")

shapiro.test(res)
```


```{r}
mod_bis_ga <- gamlss(price ~ 1 + pseed + goutput + noutput  + pphosph + varieties + bimas, random = ~1 | region,family = GA, data = data_2)
mod_bis_ga_2 <- gamlss(price ~ 1 + pseed + goutput + noutput  + pphosph + bimas, random = ~1 | region,family = GA, data = data_2)
AIC(mod_bis_ga,mod_bis_ga_2) # Il modello con varieties è migliore
summary(mod_ga)
```
```{r}
res_ga=residuals(mod_bis_ga)
ggplot(data.frame(res_ga), aes(x = res_ga)) +
  geom_histogram(binwidth = 0.1, fill = "blue", color = "black", alpha = 0.7) +
  labs(title = "Istogramma dei residui", x = "Residui", y = "Frequenza")
```
```{r}
par(mfrow=c(1,2))

qqnorm(res_ga)
qqline(res_ga, col = "red")

shapiro.test(res_ga)
```



```{r}
mod_logno <- gamlss(price ~ 1 + pseed + goutput + noutput  + pphosph + varieties + bimas, random = ~1 | region,family = LOGNO, data = data_2)
a=AIC(mod_bis_ga,mod_logno)
b=BIC(mod_bis_ga,mod_logno)
plot(mod_bis_ga, which = 1, main = "Gamma - Residui normalizzati")
plot(mod_logno, which = 1, main = "LOGNO - Residui normalizzati")
cbind(a[2],b[2])
print("mod_bis_ga")
summary(mod_bis_ga)
print("mod_logno")
summary(mod_logno)
```



```{r}
res_logno=residuals(mod_logno)
ggplot(data.frame(res_logno), aes(x = res_logno)) +
  geom_histogram(binwidth = 0.1, fill = "blue", color = "black", alpha = 0.7) +
  labs(title = "Istogramma dei residui", x = "Residui", y = "Frequenza")
```



```{r}
par(mfrow=c(1,2))

qqnorm(res_logno)
qqline(res_logno, col = "red")

shapiro.test(res_logno)
```



# Conclusioni

